<!DOCTYPE html>
<html lang="en">
<head>
<!-- update -->
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>AstroBridge - Multi-Chain Bridge</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@lifi/sdk@2.7.0/dist/index.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap');
* {
  margin:0;
  padding:0;
  box-sizing:border-box;
  font-family:'Orbitron',sans-serif;
}
body {
  background:radial-gradient(circle at 20% 20%,#050029,#2E007A);
  color:#fff;
  min-height:100vh;
  display:flex;
  justify-content:center;
  align-items:flex-start;
  padding:2rem 1rem;
  overflow-x:hidden;
}
.container {
  background:rgba(255,255,255,0.05);
  backdrop-filter:blur(20px);
  border-radius:25px;
  padding:2rem;
  width:100%;
  max-width:720px;
  text-align:center;
  box-shadow:0 0 50px rgba(255,69,0,0.2);
  position:relative;
  z-index:2;
}
h1 {
  font-size:2.2rem;
  background:linear-gradient(90deg,#ff4500,#ff8c00,#ff69b4);
  -webkit-background-clip:text;
  color:transparent;
  margin-bottom:0.5rem;
  animation:glow 3s infinite alternate;
}
@keyframes glow {
  0%{text-shadow:0 0 5px #ff4500,0 0 10px #ff4500;}
  100%{text-shadow:0 0 20px #ff69b4,0 0 40px #ff8c00;}
}
.group {
  text-align:left;
  margin-bottom:1rem;
}
.group label {
  display:block;
  margin-bottom:0.3rem;
  color:#FFA07A;
  font-size:0.9rem;
}
input, select {
  width:100%;
  padding:0.8rem 1rem;
  border-radius:12px;
  border:1px solid rgba(255,140,0,0.3);
  background:rgba(50,20,10,0.6);
  color:#fff;
  outline:none;
  font-size:1rem;
  transition:0.3s;
}
input:focus, select:focus {
  border-color:#ff8c00;
  box-shadow:0 0 10px #ff4500;
}
button {
  width:100%;
  padding:1rem;
  margin-top:0.5rem;
  border:none;
  border-radius:15px;
  font-size:1rem;
  font-weight:600;
  cursor:pointer;
  background:linear-gradient(90deg,#ff4500,#ff8c00);
  color:#fff;
  transition:0.3s;
}
button:disabled {
  opacity:0.5;
  cursor:not-allowed;
  background:#666;
}
.status {
  min-height:1.4rem;
  margin-top:0.5rem;
  font-size:0.95rem;
}
.success {color:#32CD32;}
.warn {color:#FFA500;}
.error {color:#FF6347;}
.balance {
  margin-top:0.3rem;
  color:#FF8C00;
  font-size:0.9rem;
}
.rocket {
  position:absolute;
  bottom:10px;
  left:50%;
  transform:translateX(-50%) translateY(0);
  width:30px;
  height:60px;
  background:#ff4500;
  border-radius:15px 15px 0 0;
  box-shadow:0 0 15px #ff8c00;
  transition: transform 2s ease-in-out;
  z-index:1;
}
.rocket.launch {
  transform:translateX(-50%) translateY(-300px);
}
#txChart {
  margin-top:15px;
  background:rgba(0,0,0,0.2);
  border-radius:10px;
  padding:10px;
}
.queueList, #historyList, #feeInfo, #pointsInfo, #rewardList {
  margin-top:10px;
  font-size:0.85rem;
  color:#FFA07A;
  max-height:120px;
  overflow-y:auto;
  text-align:left;
  padding:5px;
}
.ai-panel {
  margin:15px 0;
  padding:12px;
  background:rgba(255,140,0,0.1);
  border-radius:12px;
  text-align:left;
}
.ai-status {
  font-size:1rem;
  font-weight:600;
  color:#ff8c00;
  margin-bottom:8px;
}
.ai-suggestions {
  font-size:0.85rem;
  color:#FFA07A;
}
.ai-suggestions .warn {
  color:#ff4500;
}
</style>
</head>
<body>
<div class="container">
  <h1>AstroBridge</h1>
  <p class="status" id="walletStatus">Wallet not connected</p>
  <button id="connectBtn">Connect Wallet</button>

  <div class="ai-panel">
    <div id="aiStatus" class="ai-status">ü§ñ AI Ready</div>
    <div id="aiSuggestions" class="ai-suggestions"></div>
  </div>

  <div class="group">
    <label>Token</label>
    <select id="tokenSelect"></select>
    <div class="balance" id="tokenBalance">--</div>
  </div>

  <div class="group">
    <label>From Chain</label>
    <select id="fromChain"></select>
  </div>

  <div class="group">
    <label>To Chain</label>
    <select id="toChain"></select>
  </div>

  <div class="group">
    <label>Amount</label>
    <input id="amount" type="number" step="0.001" min="0.001" placeholder="0.001"/>
  </div>

  <div class="group">
    <label>Slippage (%)</label>
    <input id="slippage" type="number" step="0.1" min="0.1" max="5" value="1"/>
  </div>

  <div id="pricePreview">Estimated USD Value: --</div>
  <div id="feeInfo">Estimated Fee: --</div>
  <div id="kycStatus">KYC: Not Verified</div>
  <div id="rewardList">NFT Rewards: None</div>
  <button id="bridgeBtn" disabled>Cross-Chain Transfer</button>

  <canvas id="txChart" height="120"></canvas>
  <div class="queueList" id="queueList">Queue: Empty</div>
  <div class="queueList" id="historyList">History: Empty</div>
  <div class="queueList" id="pointsInfo">Points: 0</div>

  <div class="rocket" id="rocket"></div>
</div>

<script>
let provider, signer, account, lifi, tokenContract;
let txQueue = [], txHistory = [], points = 0, txChart = null;

const CHAINS = [
  {id:1,name:"Ethereum"},{id:56,name:"BSC"},{id:137,name:"Polygon"},
  {id:42161,name:"Arbitrum"},{id:10,name:"Optimism"},{id:43114,name:"Avalanche"},{id:250,name:"Fantom"}
];
const TOKENS = {
  ASTRO: "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853",
  USDT: "0xTestUSDT",
  USDC: "0xTestUSDC"
};

const DOM = {
  walletStatus: document.getElementById('walletStatus'),
  connectBtn: document.getElementById('connectBtn'),
  bridgeBtn: document.getElementById('bridgeBtn'),
  status: document.getElementById('status'),
  tokenSelect: document.getElementById('tokenSelect'),
  fromChain: document.getElementById('fromChain'),
  toChain: document.getElementById('toChain'),
  amount: document.getElementById('amount'),
  slippage: document.getElementById('slippage'),
  tokenBalance: document.getElementById('tokenBalance'),
  rocket: document.getElementById('rocket'),
  pricePreview: document.getElementById('pricePreview'),
  feeInfo: document.getElementById('feeInfo'),
  queueList: document.getElementById('queueList'),
  historyList: document.getElementById('historyList'),
  pointsInfo: document.getElementById('pointsInfo'),
  rewardList: document.getElementById('rewardList'),
  aiStatus: document.getElementById('aiStatus'),
  aiSuggestions: document.getElementById('aiSuggestions'),
  kycStatus: document.getElementById('kycStatus'),
  txChart: document.getElementById('txChart')
};

// ===== AI È£éÈô©ÊèêÁ§∫ =====
class BridgeAI {
  constructor() { this.reset(); }
  reset() { this.status = "ü§ñ AI Ready"; this.suggestions = []; this.warnings = []; }
  async runCheck(data) {
    this.reset(); this.status = "ü§ñ Analyzing...";
    this.checkWallet(data.account);
    this.checkBalance(data.balance, data.amount);
    this.checkChain(data.from, data.to);
    this.checkSlippage(data.slippage);
    this.status = `ü§ñ ${this.warnings.length ? '‚ö†Ô∏è Attention' : '‚úÖ Safe'}`;
    return { status: this.status, suggestions: this.suggestions, warnings: this.warnings };
  }
  checkWallet(acc) {
    acc ? this.suggestions.push(`‚úÖ Connected: ${acc.slice(0,6)}...`) : this.warnings.push("‚ùå Wallet not connected");
  }
  checkBalance(bal, amt) {
    if (bal && parseFloat(amt) > parseFloat(bal)) {
      this.warnings.push(`‚ö†Ô∏è Amount exceeds balance (${bal})`);
    } else if (bal) {
      this.suggestions.push(`‚úÖ Balance: ${bal}`);
    }
  }
  checkChain(from, to) {
    from === to ? this.warnings.push("‚ö†Ô∏è Same chain not allowed") : this.suggestions.push(`‚úÖ Cross-chain: ${from} ‚Üí ${to}`);
  }
  checkSlippage(s) {
    s > 1 ? this.warnings.push(`‚ö†Ô∏è Slippage (${s}%) high, ‚â§1% recommended`) : this.suggestions.push(`‚úÖ Slippage (${s}%) ok`);
  }
}
const bridgeAI = new BridgeAI();

function showAI(report) {
  DOM.aiStatus.textContent = report.status;
  let html = '';
  report.suggestions.forEach(s => html += `<div>${s}</div>`);
  report.warnings.forEach(w => html += `<div class="warn">${w}</div>`);
  DOM.aiSuggestions.innerHTML = html;
}

// ===== ÂàùÂßãÂåñ LiFi =====
async function initLiFi() {
  lifi = new LiFi({ integrator: "AstroBridge" });
}

// ===== Èí±ÂåÖËøûÊé• =====
function setStatus(el, msg, type = '') {
  el.textContent = msg;
  el.className = `status ${type}`;
}
function setLoading(isLoading) {
  DOM.connectBtn.disabled = isLoading;
  DOM.bridgeBtn.disabled = isLoading || !account;
  DOM.connectBtn.textContent = isLoading ? "Connecting..." : "Connect Wallet";
}
function watchNetwork() {
  if (window.ethereum) {
    window.ethereum.on('chainChanged', () => window.location.reload());
    window.ethereum.on('accountsChanged', () => window.location.reload());
  }
}

DOM.connectBtn.onclick = async () => {
  if (!window.ethereum) {
    setStatus(DOM.walletStatus, "MetaMask not found", "error");
    return;
  }
  setLoading(true);
  try {
    [account] = await window.ethereum.request({ method: 'eth_requestAccounts' });
    provider = new ethers.providers.Web3Provider(window.ethereum);
    signer = provider.getSigner();
    await initLiFi();
    watchNetwork();
    populateChainsAndTokens();
    await updateBalance();
    await checkKYC();
    await fetchTxHistoryFromBackend();
    setStatus(DOM.walletStatus, `Connected: ${account.slice(0,6)}...${account.slice(-4)}`, "success");
    DOM.bridgeBtn.disabled = false;
    updateAI();
    await fetchNFTRewards();
  } catch (e) {
    setStatus(DOM.walletStatus, "Connection failed", "error");
  } finally {
    setLoading(false);
  }
};

function populateChainsAndTokens() {
  CHAINS.forEach(c => {
    const o = document.createElement('option');
    o.value = c.id;
    o.textContent = c.name;
    DOM.fromChain.appendChild(o);
  });
  CHAINS.forEach(c => {
    const o = document.createElement('option');
    o.value = c.id;
    o.textContent = c.name;
    DOM.toChain.appendChild(o);
  });
  Object.keys(TOKENS).forEach(t => {
    const o = document.createElement('option');
    o.value = t;
    o.textContent = t;
    DOM.tokenSelect.appendChild(o);
  });
}

// ===== Êõ¥Êñ∞‰ΩôÈ¢ù =====
async function updateBalance() {
  if (!account || !signer) return "--";
  try {
    tokenContract = new ethers.Contract(TOKENS[DOM.tokenSelect.value], ["function balanceOf(address) view returns (uint256)"], signer);
    const bal = await tokenContract.balanceOf(account);
    const formatted = parseFloat(ethers.utils.formatEther(bal)).toFixed(4);
    DOM.tokenBalance.textContent = `Balance: ${formatted} ${DOM.tokenSelect.value}`;
    await fetchRealTimeRates(formatted);
    return formatted;
  } catch (e) {
    DOM.tokenBalance.textContent = "Balance: --";
    return "--";
  }
}

// ===== ÂêéÁ´Ø KYC È™åËØÅ =====
async function checkKYC() {
  try {
    const res = await fetch(`/api/kyc?address=${account}`);
    const data = await res.json();
    DOM.kycStatus.textContent = data.verified ? "KYC: Verified" : "KYC: Not Verified";
  } catch (e) {
    DOM.kycStatus.textContent = "KYC: Error";
  }
}

// ===== AI Êõ¥Êñ∞ =====
async function updateAI() {
  const balance = await updateBalance();
  const data = {
    account,
    balance,
    amount: DOM.amount.value || 0,
    from: DOM.fromChain.value,
    to: DOM.toChain.value,
    slippage: DOM.slippage.value
  };
  const report = await bridgeAI.runCheck(data);
  showAI(report);
}

// ===== NFT Â•ñÂä± =====
async function fetchNFTRewards() {
  try {
    const res = await fetch(`/api/reward?address=${account}`);
    const data = await res.json();
    DOM.rewardList.textContent = `NFT Rewards: ${data.nfts.length ? data.nfts.join(", ") : "None"}`;
  } catch (e) {
    DOM.rewardList.textContent = "NFT Rewards: Error";
  }
}

// ===== ÂÆûÊó∂Ê±áÁéáÂíåÊâãÁª≠Ë¥π =====
async function fetchRealTimeRates(balance) {
  try {
    const res = await fetch(`/api/rates?token=${DOM.tokenSelect.value}`);
    const data = await res.json();
    DOM.pricePreview.textContent = `Estimated USD Value: $${(balance * data.price).toFixed(2)}`;
    DOM.feeInfo.textContent = `Estimated Fee: $${(balance * data.fee).toFixed(2)}`;
  } catch (e) {
    DOM.pricePreview.textContent = "Estimated USD Value: --";
    DOM.feeInfo.textContent = "Estimated Fee: --";
  }
}

// ===== ‰∫§ÊòìÈòüÂàó =====
[DOM.tokenSelect, DOM.fromChain, DOM.toChain, DOM.amount, DOM.slippage].forEach(el => {
  el.addEventListener('input', updateAI);
});

DOM.bridgeBtn.onclick = async () => {
  const amt = parseFloat(DOM.amount.value);
  const slip = parseFloat(DOM.slippage.value);
  const from = DOM.fromChain.value;
  const to = DOM.toChain.value;

  if (!amt || amt <= 0) {
    setStatus(DOM.status, "Invalid amount", "error");
    return;
  }
  if (from === to) {
    setStatus(DOM.status, "Select different chains", "error");
    return;
  }
  const balance = parseFloat(await updateBalance());
  if (amt > balance) {
    setStatus(DOM.status, "Insufficient balance", "error");
    return;
  }

  const tx = {
    token: DOM.tokenSelect.value,
    from,
    to,
    amount: amt,
    slippage: slip,
    retries: 0
  };
  txQueue.push(tx);
  updateQueueList();
  if (txQueue.length === 1) processQueue();
};

// ===== Â§ÑÁêÜÈòüÂàó =====
async function processQueue() {
  if (txQueue.length === 0) return;
  const tx = txQueue[0];
  DOM.bridgeBtn.disabled = true;
  DOM.rocket.classList.add('launch');
  setStatus(DOM.status, `Processing ${tx.amount} ${tx.token}...`, "warn");

  try {
    const routes = await lifi.getRoutes({
      fromChain: parseInt(tx.from),
      toChain: parseInt(tx.to),
      fromToken: TOKENS[tx.token],
      toToken: TOKENS[tx.token],
      fromAmount: ethers.utils.parseEther(tx.amount.toString()).toString(),
      fromAddress: account,
      toAddress: account,
      options: { slippage: tx.slippage / 100 }
    });
    if (!routes?.routes.length) throw new Error("No route found");
    await lifi.executeRoute(routes.routes[0], signer);

    if (!txChart) initChart();
    txChart.data.labels.push(new Date().toLocaleTimeString());
    txChart.data.datasets[0].data.push(tx.amount * 0.01);
    txChart.update();

    points += 1;
    DOM.pointsInfo.textContent = `Points: ${points}`;

    const txRecord = {
      from: tx.from,
      to: tx.to,
      amount: tx.amount,
      token: tx.token,
      time: new Date().toISOString(),
      fromAddress: account,
      toAddress: account
    };
    txHistory.unshift(txRecord);
    updateHistoryList();
    await recordTxToBackend(txRecord);

    setStatus(DOM.status, `Transfer success! Points: ${points}`, "success");
    await fetchNFTRewards();

    txQueue.shift();
    await updateBalance();
    updateAI();
  } catch (e) {
    if (tx.retries < 3) {
      tx.retries += 1;
      setStatus(DOM.status, `Retrying... (${tx.retries})`, "warn");
      setTimeout(processQueue, 2000);
      return;
    }
    setStatus(DOM.status, "Error: " + e.message.slice(0, 60), "error");
    txQueue.shift();
  } finally {
    DOM.bridgeBtn.disabled = false;
    setTimeout(() => DOM.rocket.classList.remove('launch'), 2500);
  }
  updateQueueList();
  if (txQueue.length > 0) setTimeout(processQueue, 500);
}

// ===== ÂõæË°® =====
function initChart() {
  const ctx = DOM.txChart.getContext('2d');
  txChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Fee (USD)',
        data: [],
        borderColor: '#FF8C00',
        backgroundColor: 'rgba(255,140,0,0.1)',
        fill: true,
        tension: 0.4
      }]
    },
    options: {
      responsive: true,
      plugins: { legend: { labels: { color: '#fff' } } },
      scales: {
        x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#fff' } },
        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#fff' } }
      }
    }
  });
}

function updateQueueList() {
  const text = txQueue.map(t => `${t.token} ${t.amount} ${t.from}‚Üí${t.to}`).join(" | ");
  DOM.queueList.textContent = `Queue: ${text || "Empty"}`;
}

function updateHistoryList() {
  const text = txHistory.slice(0, 5).map(t => `${t.token} ${t.amount} ${t.from}‚Üí${t.to}`).join(" | ");
  DOM.historyList.textContent = `History: ${text || "Empty"}`;
}

// ===== ÂêéÁ´Ø‰∫§‰∫í =====
async function recordTxToBackend(tx) {
  try {
    await fetch('/api/recordTx', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(tx)
    });
  } catch (e) {
    console.error("Failed to record tx", e);
  }
}

async function fetchTxHistoryFromBackend() {
  try {
    const res = await fetch('/api/txHistory');
    const data = await res.json();
    txHistory = data;
    updateHistoryList();
  } catch (e) {
    console.error("Failed to fetch history", e);
  }
}
</script>
</body>
</html>
